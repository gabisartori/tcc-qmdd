% ----------------------------------------------------------
\chapter{Introdução}\label{chap:intro}
% ----------------------------------------------------------

Conforme os fenômenos da mecânica quântica foram melhor descritos e compreendidos, um novo paradigma para solução de problemas surge: a computação quântica. Essa nova forma de elaborar algoritmos se mostrou equivalente à computação clássica em termos de computabilidade, já, em termos de complexidade computacional (consumo de recursos), algoritmos quânticos podem oferecer soluções menos custosas para problemas que, na computação clássica, acreditava-se já terem sido resolvidos da forma mais eficaz possível. Por exemplo, dada uma lista de items em sequência sem uma organização prévia, a computação clássica entende que a melhor forma possível de verificar se determinado item está presente nessa lista é percorrendo-a, elemento por elemento, buscando pelo alvo desejado. Essa solução possui complexidade temporal O(n), o que significa que o tempo para encontrar um elemento específico cresce linearmente em relação ao tamanho da lista (uma lista 4 vezes maior que outra leva 4 vezes mais tempo para ser percorrida). Porém, Grover demonstrou que, usando da mecânica quântica, é possível resolver esse mesmo problema com uma complexidade temporal O($\sqrt{n}$). Nesse caso, uma lista 4 vezes maior que outra, leva apenas o dobro do tempo para que o elemento desejado seja encontrado. Assim, sabe-se que é possível que algoritmos quânticos superem algoritmos clássicos em desempenho, nesse caso, como a complexidade foi reduizada de $O(n)$ para $(O(\sqrt{n})$, diz-se que houve um ganho quadrático de desempenho.

Atualmente, porém, essa área de pesquisa encontra um obstáculo: a dificuldade de executar os algoritmos elaborados, dificultando significativamente o desenvolvimento de novos algoritmos, já que testá-los torna-se uma tarefa manual e demorada sem um computador para realizá-la. Essa dificuldade existe porque hardware que possibilite a execução das operações fundamentais da computação quântica é caro e raramente acessível. Além disso, mesmo quando acessível, hardware quântico moderno apresenta baixa capacidade, permitindo apenas a execução de algoritmos simples sobre casos de exemplos pequenos.

Dessa forma, para auxiliar no desenvolvimento de algoritmos quânticos, busca-se solução na simulação por meio de computadores clássicos para compensar a falta de hardware quântico para execução dos algoritmos. Visto que ambas as formas de definir algoritmos são computacionalmente equivalentes, sabe-se que todo algoritmo quântico pode ser executado em uma máquina clássica e vice-versa. Então, basta definir uma forma de converter algoritmos quânticos em algoritmos clássicos e executar essa nova versão em uma máquina clássica, cujo custo e capacidade são altamente mais favoráveis para o desenvolvimento.

Por sua vez, a simulação clássica também apresenta desafios. Devido à capacidade dos computadores quânticos de sobrepor um número exponencial de estados possíveis em relação à sua capacidade física, a simulação precisa ser capaz de armazenar uma quantia exponencial de informação, tornando o consumo de memória inviável. De forma a mitigar esse problema, diferentes técnicas de simulação surgem, tentando otimizar o consumo de memória e tempo como a simulação esparsa e o método de tableau.

Este trabalho consiste na implementação de uma dessas técnicas: o uso de diagramas de decisão para simulação de circuitos quânticos. Nessa técnica, o circuito a ser simulado tem suas portas lógicas convertidas em matrizes e a execução do circuito é representada pela multiplicação sucessiva dessas matrizes. Porém, como mencionado previamente, o tamanho da informação a ser armazenada cresce exponencialmente em relação à largura do circuito, esse crescimento é refletido nas matrizes. Por isso o QMDD (Quantum Multiple-Value Decision Diagram) é útil, essa estrutura de dados permite representar matrizes de forma concisa, explorando a redundância na composição delas. Essa técnica de compressão apresenta ganho variado, pois matrizes com maior redundância serão melhor compactadas que matrizes de menor redundância. Por exemplo, uma matriz 1000x1000 na qual todos os valores são 1 pode ser descrita exatamente dessa forma "uma matriz 1000x1000 preenchida inteiramente com o valor 1" ao invés de dedicar espaço suficiente para armazenar \num{1000000} de números uns um ao lado do outro. Já na matriz \cref{Matriz}, todos seus valores são diferentes, logo o QMDD consumirá mais memória para representá-la:
\[
  \begin{bmatrix}
    1 & 2 \\
    3 & 4
  \end{bmatrix}
  \label{Matriz}
\]

Assim, será feita uma implementação dos algoritmos necessários para simulação de um circuito quântico, envolvendo a conversão de cada porta em um QMDD que representa a matriz equivalente à porta, o produto entre dois QMDDs e a medição sobre determinado QMDD. Essa implementação então será integrada à plataforma Ket, uma interface feita para facilitar a descrição de algoritmos quânticos que. Então, por meio do módulo de simulação por QMDD, permitirá ao usuário simular de forma eficiente algoritmos que não exijam matrizes de baixa redundância para serem simulados.

Além disso, como não é intuitivamente claro quais circuitos levarão a uma matriz com alta ou baixa redundância, este trabalho buscará, também, comparar o desempenho de diferentes circuitos de forma a analisar quais, se houverem, são os aspectos em comum entre os circuitos que apresentaram ganho significativo.

\section{Metologia}
% TODO

% ----------------------------------------------------------
\section{Objetivos}
% ----------------------------------------------------------

% ----------------------------------------------------------
\subsection{Objetivo Geral}
% ----------------------------------------------------------
Implementar um novo método de simulação para o Ket, que poderá ser escolhido pelo usuário para otimizar a simulação de circuitos cujas representações matriciais possuam grande redundância.
% ----------------------------------------------------------
\subsection{Objetivos Específicos}
% ----------------------------------------------------------
\begin{enumerate}[label=O\arabic*]
  \item Compilar e descrever os algoritmos apresentados no artigo TODO

  \item Implementar um simulador utilizando os algoritmos do artigo.

  \item Integrar o simulador produzido ao código fonte do Ket.

  \item Comparar o desempenho da implementação com as outras técnicas de simulação disponíveis no Ket, identificando em quais cenários o método desenvolvido apresenta ser vantajoso.

\end{enumerate}
