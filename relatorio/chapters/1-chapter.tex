\chapter{Introdução}\label{chap:intro}

Conforme os fenômenos da mecânica quântica foram melhor descritos e compreendidos, um novo paradigma para solução de problemas surge: a computação quântica. Essa nova forma de elaborar algoritmos se mostrou equivalente à computação clássica em termos de computabilidade \cite{shor1998quantum}, já, em termos de complexidade computacional (consumo de recursos), algoritmos quânticos podem oferecer soluções menos custosas para problemas que, na computação clássica, acreditava-se já terem sido resolvidos da forma mais eficaz possível. Por exemplo, dada uma lista de items em sequência sem uma organização prévia, a computação clássica entende que a melhor forma possível de verificar se determinado item está presente nessa lista é percorrendo-a, elemento por elemento, buscando pelo alvo desejado. Essa solução possui complexidade temporal O(n), o que significa que o tempo para encontrar um elemento específico cresce linearmente em relação ao tamanho da lista (uma lista 4 vezes maior que outra leva 4 vezes mais tempo para ser percorrida). Porém, Grover [Quote: Grover's algorithm] demonstrou que, usando da mecânica quântica, é possível resolver esse mesmo problema com uma complexidade temporal O($\sqrt{n}$). Nesse caso, uma lista 4 vezes maior que outra, leva apenas o dobro do tempo para que o elemento desejado seja encontrado. Assim, sabe-se que é possível que algoritmos quânticos superem algoritmos clássicos em desempenho, nesse caso, como a complexidade foi reduizada de $O(n)$ para $O(\sqrt{n})$, diz-se que houve um ganho quadrático de desempenho.

Atualmente, porém, essa área de pesquisa encontra um obstáculo: a dificuldade de executar os algoritmos elaborados, dificultando significativamente o desenvolvimento de novos algoritmos, já que testá-los torna-se uma tarefa manual e demorada sem um computador para realizá-la. Essa dificuldade existe porque hardware que possibilite a execução das operações fundamentais da computação quântica é caro e raramente acessível. Além disso, mesmo quando acessível, hardware quântico moderno apresenta baixa capacidade, permitindo apenas a execução de algoritmos simples sobre casos de exemplos pequenos \cite{golec2024quantum}.

Dessa forma, para auxiliar no desenvolvimento de algoritmos quânticos, busca-se solução na simulação por meio de computadores clássicos para compensar a falta de hardware quântico. Visto que ambas as formas de definir algoritmos são computacionalmente equivalentes, sabe-se que todo algoritmo quântico pode ser executado em uma máquina clássica e vice-versa. Então, basta definir uma forma de converter algoritmos quânticos em algoritmos clássicos e executar essa nova versão em uma máquina clássica, cujo custo e capacidade são altamente mais favoráveis para o desenvolvimento. Neste trabalho, essa conversão será feita decompondo o circuito em matrizes, cada porta lógica é representada por uma matriz e a execução do algoritmo se dá pelo produto das matrizes \cite{deutsch1989quantum}.

Por sua vez, a simulação clássica também apresenta desafios. Devido à capacidade dos computadores quânticos de sobrepor um número exponencial de estados possíveis em relação à sua capacidade física, a simulação precisa ser capaz de armazenar uma quantia exponencial de informação, tornando o consumo de memória inviável. De forma a mitigar esse problema, diferentes técnicas de simulação surgem, tentando otimizar o consumo de memória e tempo, como a simulação esparsa \cite{jaques2022leveraging} e o método de tableau \cite{aaronson2004improved}.

Este trabalho consiste na implementação de uma dessas técnicas: o uso de diagramas de decisão para simulação de circuitos quânticos. Nessa técnica, o circuito a ser simulado tem suas portas lógicas convertidas em matrizes e a execução do circuito é representada pela multiplicação sucessiva dessas matrizes. Porém, como mencionado previamente, o tamanho da informação a ser armazenada cresce exponencialmente em relação à largura do circuito, esse crescimento é refletido nas matrizes. Por isso o QMDD (Quantum Multiple-Value Decision Diagram) é útil, essa estrutura de dados permite representar matrizes de forma concisa, explorando a redundância na composição delas \cite{fujita1997multi}. Essa técnica de compressão apresenta ganho variado, pois matrizes com maior redundância serão melhor compactadas que matrizes de menor redundância. Por exemplo, uma matriz 1000x1000 na qual todos os valores são 1 pode ser descrita exatamente dessa forma "uma matriz 1000x1000 preenchida inteiramente com o valor 1" ao invés de dedicar espaço suficiente para armazenar \num{1000000} de números 1's um ao lado do outro. Já na \cref{distinctmatrix}, todos seus valores são diferentes, logo o QMDD não será capaz de compactá-la com a mesma eficácia, consumindo mais memória.
\[
  \begin{bmatrix}
    1 & 2 & \cdots & 1000 \\
    1001 & 1002 & \cdots & 2000 \\
    \vdots & \vdots & \ddots & \vdots \\
    999001 & 999002 & \cdots & 1000000
  \end{bmatrix}
  \label{distinctmatrix}
\]

Assim, será feita uma implementação dos algoritmos necessários para simulação de um circuito quântico, envolvendo a conversão de cada porta em um QMDD que representa a matriz equivalente à porta, o produto entre dois QMDDs e a medição sobre determinado QMDD. Essa implementação então será integrada à plataforma Ket \cite{evandro}, uma interface feita para facilitar a descrição de algoritmos quânticos que. Então, por meio do módulo de simulação por QMDD, o usuário poderá simular de forma eficiente algoritmos que não exijam matrizes de baixa redundância.

Além disso, não é intuitivamente claro quais circuitos levarão a uma matriz com alta ou baixa redundância. Então, este trabalho buscará comparar o desempenho de diferentes circuitos de forma a analisar se existem aspectos em comum entre os circuitos que apresentaram ganho significativo.

\section{Metologia}

Este trabalho apresenta a construção de um simulador a partir de um método de simulação ainda não utilizado pela plataforma Ket. A construção desse simulador será feita por meio da compilação de algoritmos existentes na literatura de forma cumprir todos os requisitos do Ket para simulação de circuitos quânticos.

Os resultados da implementação serão analisados de forma qualiquantitativa. Será feita uma comparação das estatísticas produzidas pela análise de desempenho do simulador implementado e dos simuladores já disponíveis no Ket de forma a verifcar que existem cenários nos quais o novo simulador apresenta vantagem em relação aos já existentes. Além disso, será análisado em quais cenários o novo simulador apresentou vantagem e em quais o ganho não foi significativo para identificar aspectos em comum dos algoritmos quânticos que puderam ser simulados de forma eficaz por meio do método apresentado. 

\section{Objetivos}

\subsection{Objetivo Geral}

Implementar um novo método de simulação para o Ket, que poderá ser escolhido pelo usuário para otimizar a simulação de circuitos cujas representações matriciais possuam grande redundância.

\subsection{Objetivos Específicos}

\begin{enumerate}[label=O\arabic*]
  \item Compilar e descrever os algoritmos necessários para o QMDD;

  \item Implementar um simulador utilizando os algoritmos do artigo;

  \item Integrar o simulador produzido ao código fonte do Ket;

  \item Identificar em quais cenários o simulador produzido apresenta vantagem em relação aos métodos de simulação já disponíveis na plataforma.
\end{enumerate}

\section{Trabalhos Correlatos}

%TODO
Existem dois artigos que descrevem o funcionamento do QMDD e oferecem implementações do algoritmos como exemplos e também para exibir o consumo de memória para circuitos pequenos. Nenhuma implementação foi em Rust e também há poucas conclusões sobre os tipos de circuitos nos quais o QMDD apresenta vantagem ou não.